* Preface
  In order to support multiple different operation systems, this project uses Docker. Project dependencies are downloaded using Gradle, which also handles running the tasks which form the meat of this assignment.
  Gradle is being used because it's a highly maintained build tool with a lot of open source documentation. It's quite fast and has remote build cache support as well as incremental compilation and other very nice features.
* Setup
  Make sure your Docker/docker-compose versions are up-to-date. To be safe, I'd try matching my version below.
  
  - Docker version: 19.03.13
  - Docker-compose version: 1.27.4

  The following aren't needed, since the project is containerized, however, I'm providing it in case any local development happens.
  - Gradle version: 6.6.1
  - Java version: 14.0

** Steps    
  - Clone the repository and checkout the *dev* branch:
    #+begin_src bash
      git clone git@github.com:SlackRecruiting/br-code-exercise-170536289.git

      cd <project_name>

      git checkout dev
    #+end_src
  - Create a *gradle.properties* file with your credentials (for GitHub API requests), replacing the words inside the brackets with your credentials. You can find out how to generate an API token here: https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token.
    #+begin_src bash
      cd <project_dir>/release-tools

      # This is your GitHub username
      echo "github_username=<username>" >> gradle.properties

      # This is your GitHub API token
      echo "github_token=<token>" >> gradle.properties"
    #+end_src
    
  - Run the Docker container (make sure you're using an updated version of Docker at least according to the specs I wrote above).     This will then run the container, which runs each of the three tasks. The result of this will be a newly created branch, an updated project name/version, and a new feature flag diff.
    #+begin_src bash
cd <project_dir>/release-tools/docker

docker-compose up
    #+end_src
** Running Tasks
   In order to run a specific task, you can do either of the following:
  1. Docker only: You'll need to change the Dockerfile. On line 5 of *<project dir>/release-tools/docker/Dockerfile/* you'll find the entrypoint command that executes when the container is run. Change it to which ever task you'd like to run and then rebuild the image like below. *Adding --stacktrace to the Gradle command will give you a stacktrace that will aid in debugging*

#+begin_src bash
cd <root dir>/release-tools/docker

# You'll need to rebuild the image
docker-compose up --build
#+end_src

  2. Without Docker (you'll need Gradle, Java, etc to be able to run): You can run commands inside the Gradle project.
#+begin_src bash
cd <project dir>/release-tools/

# Replace task name with your desired task. Note the optional stacktrace flag.
./gradlew <task name> [--stacktrace]
#+end_src
* Troubleshooting
  - Make sure you have Docker installed.
  - Check the correct version of Docker is being used. See the versions that I'm using to make sure you're compatible.
  - Make sure Docker is running (this actually happens to me relatively frequently)
  - Make sure you have a functioning internet connection, since requests to GitHub are being made. You can curl -u<username:token> https://api.github.com/repos/SlackRecruiting/br-code-exercise-170536289/git/refs/heads/master or other GitHub API endpoints to see if it's the application or the server failing.
  - No credentials file was added, in which case requests to GitHub will fail with "HTTP 404: Not Found" errors. Make sure that this file is put under the *release-tools* directory, since this is where Gradle looks for it.
  - *Adding --stacktrace to the Gradle command will give you a stacktrace that will aid in debugging*
* Architecture
** Directory Hierarchy  
  - The directory structure is designed in such a way that supports modification and extensibility. Additional plugins/tasks/utility classes can be added easily by creating a class and putting them into their respective directory.
  - The architecture of this project is designed to be a plug-and-play plugin that can be injected into any Gradle project.
  - The *buildSrc/* directory contains the plugin code (e.g. tasks that can be used by the main project, e.g. the parent directory of *buildSrc*). *buildSrc* is a Gradle-specific directory which is a self-contained Gradle project (with its own build.gradle which can download independent dependencies from the main project) that gets packaged as a .jar and put into the Java classpath. The main project can then import the classes (such as the Gradle tasks) from this .jar.

** Task classes
   Task classes contain a method annotated by *@TaskAction* which is the main task method that will be run when the task represented by this task is used. Each task has detailed print statements for when running on CI/CD, which aids in debugging when looking at the log statements.
   The following task classes are defined in *buildSrc/src/main/groovy/tasks/*:
  - CutBranchTask: This task class queries the current name and version and then creates a (remote) branch named "<release name>/<release version>". If a branch by that name already exists, then a task exception is thrown with a message saying that the branch already exists. Note that the new branch will be based off of "master", which is a field in the CutBranchTask that can be changed if the base branch needs to be changed.
  - GenerateFFDiffTask: This task class generates a diff between the (local) current branch's feature flag statuses and the previous branch's statuses. If the previous branch does not exist (e.g. when the current branch is the first one), then the current version's FF content will be the displayed as the contents of the diff file.
    
    The feature flag diff task will create a diff file in the same directory as FF.csv. Each record in the CSV will be the diff of the current and previous branch if it exists. If the following is the actual diff:
| Cake/1.2_name | Cake/1.2_version | Beer/1.1_name | Beer/1.1_version |
|---------------+------------------+---------------+------------------|
| FLAG_B        | OFF              | FLAG_B        | ON               |
| FLAG_C        | ON               | FLAG_C        | OFF              |

Then the resulting CSV will look like this:

    #+begin_src CSV
[Cake/1.2]_name,[Cake/1.2]_version,[Beer/1.1_name],[Beer/1.1]_version
Flag_B,OFF,Flag_B,ON
Flag_C,ON,Flag_C,OFF
    #+end_src
  
  - UpdateReleaseVersionTask: The task class will update the project's name and version to the next one. In case that the "releases.csv" file does not contain a next one (e.g. when the current version is the last), then a task exception will be thrown.

** Plugin classes    
  The task classes are then registered to the plugin in *buildSrc/src/main/groovy/plugins/CodeFreezePlugin.groovy*. This plugin is then registered as a plugin in the main project *release-tools/build.gradle*.
  This means that the tasks are able to be used in the main project (e.g. someone can do 'gradle cutBranch' from the *release-tools/* directory).

** Utility classes
  There are also some utility classes (defined in *buildSrc/src/main/groovy/utils/*):
  - GitUtils: this class is a wrapper for Git related API requests.
  - ReleaseUtils: this class contains some methods for querying for release information from the provided .plist and .csv files.
  - Release: a class that represents a release with a name and version, previous name and version, and next name and version. This is useful to store the information so the information isn't queried many times.

* Assumptions
  - I assumed these sorts of tasks (cutting branch, updating version, etc) would be performed using a build tool like Gradle, Maven, Bazel, etc instead of having a bash/python script that may or may not be called by Jenkins.
  - I assumed that whoever uses this (Jenkins or an actual user) would provide a *gradle.properties* file in the *release-tools/* directory that contains two properties that are required to authenticate against GitHub.
* Future Possible Sources of Error
  - This uses a fair amount of external dependencies (Gradle, CSV/XML parsing libraries), each of which are well tested and well reviewed, but this is certainly a possible point of failure in the future
  - Memory usage is relatively high, since each of the files (.plist, .csv) are loaded into memory entirely in order to parse them. I made the assumption that since these are configuration files, they won't grow very large, however, this may not necessarily be the case in a production environment.
